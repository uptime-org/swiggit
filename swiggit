#!/bin/bash

# 🍀 SWIGGIT - Multi-Organization Git CLI Tool 💰
# Irish Gold Theme with Identity Management

set -e

# Handle init command first (doesn't need config)
if [[ "${1:-}" == "init" ]]; then
    # Define colors for init command
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    GOLD='\033[1;93m'
    EMERALD='\033[1;92m'
    BG_GOLD='\033[48;5;220m'
    BG_GREEN='\033[48;5;34m'
    BG_RAINBOW='\033[48;5;57m'
    NC='\033[0m'
    
    # Init-specific functions
    print_header() {
        echo -e "${BG_GREEN}${GOLD}╔══════════════════════════════════════════╗${NC}"
        echo -e "${BG_GREEN}${GOLD}║${NC} 🍀 ${RED}S${YELLOW}W${GOLD}I${EMERALD}G${CYAN}G${BLUE}I${PURPLE}T${NC} 🌈💰 Multi-Org Git CLI 🍀 ${BG_GREEN}${GOLD}║${NC}"
        echo -e "${BG_GREEN}${GOLD}╚══════════════════════════════════════════╝${NC}"
    }
    
    print_success() {
        echo -e "🌈 Validating..." && sleep 0.3 && echo -e "... 💰 Success!"
        echo -e "${BG_GOLD}${GREEN}🍀 ${GOLD}💰 $1${NC}"
    }
    
    print_info() {
        echo -e "${CYAN}☁️ ${CYAN}🌈 $1${NC}"
    }
    
    print_warning() {
        echo -e "${BG_GREEN}${YELLOW}⚡ ${YELLOW}🍀 $1${NC}"
    }
    
    # Initialize swiggit config
    init_config() {
        print_header
        echo -e "🆕 Initializing Swiggit Config"
        echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        if [[ -f ".swiggit.json" ]]; then
            print_warning "⚠️  .swiggit.json already exists!"
            read -p "Overwrite existing config? [y/N]: " overwrite
            if [[ ! "$overwrite" =~ ^[yY] ]]; then
                print_info "Init cancelled"
                return 0
            fi
        fi
        
        print_info "📄 Creating .swiggit.json config file..."
        
        cat > .swiggit.json << 'EOF'
{
  "default": {
    "org": "personal",
    "repo": "my-project",
    "branch": "main",
    "license": "MIT",
    "visibility": "private"
  },
  "ssh": {
    "options": "-o IdentitiesOnly=yes -o StrictHostKeyChecking=no",
    "key_path": "./.ssh/id_rsa"
  },
  "git": {
    "user_name": "your-name",
    "user_email": "your-email@domain.com"
  },
  "organizations": {
    "personal": {
      "name": "personal",
      "description": "Personal GitHub Account",
      "git_user_name": "your-name",
      "git_user_email": "your-email@domain.com",
      "ssh_key_path": "./.ssh/id_rsa",
      "github_username": "your-github-username",
      "github_token": "REPLACE_WITH_YOUR_PERSONAL_ACCESS_TOKEN",
      "expected_user": "your-github-username"
    }
  },
  "github": {
    "host": "github.com",
    "api_url": "https://api.github.com"
  },
  "project": {
    "name": "My Project",
    "description": "Project description"
  },
  "cli": {
    "auto_push": true,
    "auto_set_upstream": true,
    "verbose_output": false,
    "colorized_output": true
  }
}
EOF
        
        if [[ $? -eq 0 ]]; then
            print_success "Config file created: .swiggit.json"
            echo ""
            print_info "📝 Next steps:"
            echo "  1. Edit .swiggit.json with your details"
            echo "  2. Add your GitHub personal access token"
            echo "  3. Set your SSH key path and git identity"
            echo "  4. Run: swiggit identity"
            echo ""
            print_info "🔑 Get GitHub token: https://github.com/settings/tokens"
            print_info "🔗 Scopes needed: 'repo' (full control of private repositories)"
        else
            echo "❌ Failed to create config file"
            return 1
        fi
    }
    
    init_config
    exit 0
fi

# Load config from current working directory
CONFIG_FILE=".swiggit.json"
if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "❌ Config file $CONFIG_FILE not found in current directory!"
    echo "💡 Each project needs its own .swiggit.json config file"
    echo "   Run: swiggit init"
    exit 1
fi

# Colors 🌈💰🍀
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
GOLD='\033[1;93m'
EMERALD='\033[1;92m'
BG_GOLD='\033[48;5;220m'
BG_GREEN='\033[48;5;34m'
BG_RAINBOW='\033[48;5;57m'
NC='\033[0m' # No Color

# Functions
print_header() {
    echo -e "${BG_GREEN}${GOLD}╔══════════════════════════════════════════╗${NC}"
    echo -e "${BG_GREEN}${GOLD}║${NC} 🍀 ${RED}S${YELLOW}W${GOLD}I${EMERALD}G${CYAN}G${BLUE}I${PURPLE}T${NC} 🌈💰 Multi-Org Git CLI 🍀 ${BG_GREEN}${GOLD}║${NC}"
    echo -e "${BG_GREEN}${GOLD}╚══════════════════════════════════════════╝${NC}"
}

print_success() {
    echo -e "🌈 Validating..." && sleep 0.3 && echo -e "... 💰 Success!"
    echo -e "${BG_GOLD}${GREEN}🍀 ${GOLD}💰 $1${NC}"
}

print_error() {
    echo -e "${BG_RAINBOW}${RED}☁️ ${PURPLE}⚡ $1${NC}"
}

print_info() {
    echo -e "${CYAN}☁️ ${CYAN}🌈 $1${NC}"
}

print_warning() {
    echo -e "${BG_GREEN}${YELLOW}⚡ ${YELLOW}🍀 $1${NC}"
}

# Get config values using jq
get_config() {
    local key="$1"
    jq -r ".organizations.personal.$key // empty" "$CONFIG_FILE" 2>/dev/null || echo ""
}

get_global_config() {
    local key="$1"
    jq -r ".$key // empty" "$CONFIG_FILE" 2>/dev/null || echo ""
}

# Git command with identity injection
run_git() {
    local git_user=$(get_config "git_user_name")
    local git_email=$(get_config "git_user_email") 
    local ssh_key=$(get_config "ssh_key_path")
    
    if [[ -z "$git_user" || -z "$git_email" || -z "$ssh_key" ]]; then
        print_error "Missing git configuration in $CONFIG_FILE"
        return 1
    fi
    
    print_info "🔧 Git: $*"
    
    export GIT_SSH_COMMAND="ssh -i $ssh_key -o IdentitiesOnly=yes"
    git -c user.name="$git_user" -c user.email="$git_email" "$@"
}

# Show current identity
show_identity() {
    local git_user=$(get_config "git_user_name")
    local git_email=$(get_config "git_user_email")
    local ssh_key=$(get_config "ssh_key_path")
    local github_user=$(get_config "github_username")
    
    print_header
    echo ""
    echo -e "${PURPLE}✨ ${YELLOW}Current Identity${NC} 🌈"
    echo -e "${CYAN}👤 Git User:${NC} ${EMERALD}$git_user <$git_email>${NC}"
    echo -e "${CYAN}🔑 SSH Key:${NC} ${GOLD}$ssh_key${NC}"
    echo -e "${CYAN}🐙 GitHub:${NC} ${PURPLE}$github_user${NC}"
    echo ""
}


# Create repository
create_repo() {
    print_header
    echo -e "🆕 Creating New Repository"
    echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    show_identity
    
    read -p "Repository name: " repo_name
    if [[ -z "$repo_name" ]]; then
        print_error "Repository name cannot be empty"
        return 1
    fi
    
    read -p "Description (optional): " description
    read -p "Make repository public? [y/N]: " make_public
    
    local visibility="private"
    if [[ "$make_public" =~ ^[yY] ]]; then
        visibility="public"
        private_flag="false"
    else
        private_flag="true"
    fi
    
    echo ""
    echo -e "${YELLOW}Repository Details:${NC}"
    echo -e "Name: $repo_name"
    echo -e "Description: ${description:-'(none)'}"
    echo -e "Visibility: $visibility"
    echo ""
    
    read -p "Create this repository? [y/N]: " confirm
    if [[ ! "$confirm" =~ ^[yY] ]]; then
        print_info "Repository creation cancelled"
        return 0
    fi
    
    # Create repository via GitHub API
    local github_token=$(get_config "github_token")
    if [[ -z "$github_token" || "$github_token" == "REPLACE_WITH_YOUR_PERSONAL_ACCESS_TOKEN" ]]; then
        print_error "No GitHub token configured!"
        print_info "1. Go to https://github.com/settings/tokens"
        print_info "2. Generate a new token with 'repo' scope"
        print_info "3. Add it to .swiggit.json as 'github_token'"
        return 1
    fi
    
    print_info "Creating repository via GitHub API..."
    
    local payload="{\"name\":\"$repo_name\",\"private\":$private_flag"
    if [[ -n "$description" ]]; then
        payload="$payload,\"description\":\"$description\""
    fi
    payload="$payload}"
    
    local response=$(curl -s -X POST \
        -H "Accept: application/vnd.github.v3+json" \
        -H "User-Agent: swiggit-cli-bash" \
        -H "Authorization: token $github_token" \
        -d "$payload" \
        "https://api.github.com/user/repos")
    
    if echo "$response" | jq -e '.html_url' >/dev/null 2>&1; then
        local repo_url=$(echo "$response" | jq -r '.html_url')
        print_success "Repository created: $repo_name"
        print_info "Repository URL: $repo_url"
        
        # Setup remote if we're in a git repo
        if [[ -d ".git" ]]; then
            read -p "Setup this directory as the repository? [y/N]: " setup_repo
            if [[ "$setup_repo" =~ ^[yY] ]]; then
                setup_and_push "$repo_name"
            fi
        fi
    else
        print_error "Failed to create repository"
        echo "$response" | jq -r '.message // .'
        return 1
    fi
}

# Setup remote and push
setup_and_push() {
    local repo_name="$1"
    local github_user=$(get_config "github_username")
    local repo_url="git@github.com:$github_user/$repo_name.git"
    
    print_info "Setting up remote and pushing..."
    print_info "Repository URL: $repo_url"
    
    # Remove existing origin
    git remote remove origin 2>/dev/null || true
    
    # Add new origin
    run_git remote add origin "$repo_url"
    
    # Add, commit, and push
    if ! run_git add .; then
        print_error "Failed to add files"
        return 1
    fi
    
    if ! run_git commit -m 'Initial commit: Irish gold Swiggit CLI! 🍀💰'; then
        print_warning "No changes to commit, but remote is set up"
        return 0
    fi
    
    if run_git push -u origin main; then
        print_success "Repository pushed successfully! 🌈"
    else
        print_error "Push failed"
        return 1
    fi
}

# Git operations
git_add() {
    if [[ $# -eq 0 ]]; then
        run_git add .
    else
        run_git add "$@"
    fi
}

git_commit() {
    if [[ $# -eq 0 ]]; then
        read -p "Commit message: " message
        if [[ -z "$message" ]]; then
            print_error "Commit message cannot be empty"
            return 1
        fi
        run_git commit -m "$message"
    else
        # Properly quote the entire message
        local commit_msg="$*"
        run_git commit -m "$commit_msg"
    fi
}

git_push() {
    # Auto-setup origin remote if it doesn't exist
    if ! git remote get-url origin >/dev/null 2>&1; then
        local github_user=$(get_config "github_username")
        if [[ -n "$github_user" ]]; then
            local repo_name=$(basename "$(pwd)")
            local repo_url="git@github.com:$github_user/$repo_name.git"
            
            print_warning "🔗 No origin remote found. Auto-setting: $repo_url"
            print_info "💡 This works for both fresh projects and existing repos"
            run_git remote add origin "$repo_url"
        else
            print_error "No origin remote and no github_username configured"
            return 1
        fi
    fi
    
    if [[ $# -eq 0 ]]; then
        # Check if we need to set upstream
        local current_branch=$(git branch --show-current 2>/dev/null || echo "main")
        if ! git rev-parse --abbrev-ref "$current_branch@{upstream}" >/dev/null 2>&1; then
            print_info "⬆️ Setting upstream for branch $current_branch"
            
            # Try to push, handle both fresh and existing repo scenarios
            if run_git push -u origin "$current_branch" 2>/dev/null; then
                print_success "Successfully pushed to remote! 🚀"
            else
                print_warning "🤔 Push failed - might be an existing repo with different history"
                print_info "💪 Trying force push to take over existing repo..."
                
                if run_git push -u origin "$current_branch" --force; then
                    print_success "Force push successful! Took over existing repo 💪"
                else
                    print_error "Failed to push. Check if repo exists and you have access"
                    return 1
                fi
            fi
        else
            run_git push
        fi
    else
        run_git push "$@"
    fi
}

git_rebase() {
    if [[ $# -eq 0 ]]; then
        run_git rebase -i HEAD~3
    else
        run_git rebase "$@"
    fi
}

git_status() {
    run_git status "$@"
}

git_pull() {
    run_git pull "$@"
}

# Usage
usage() {
    print_header
    echo ""
echo -e "${GOLD}Usage:${NC}"
echo -e "  ${CYAN}swiggit init${NC}           - Create .swiggit.json config file"
echo -e "  ${CYAN}swiggit create${NC}         - Create a new repository"
echo -e "  ${CYAN}swiggit identity${NC}       - Show current identity"
echo -e "  ${CYAN}swiggit add [files]${NC}    - Add files (default: all files)"
echo -e "  ${CYAN}swiggit commit [msg]${NC}   - Commit with message (prompts if no msg)"
echo -e "  ${CYAN}swiggit push [args]${NC}    - Push to remote"
echo -e "  ${CYAN}swiggit pull [args]${NC}    - Pull from remote"
echo -e "  ${CYAN}swiggit rebase [args]${NC}  - Interactive rebase (default: last 3 commits)"
echo -e "  ${CYAN}swiggit status${NC}         - Git status"
    echo ""
}

# Main command dispatcher
case "${1:-}" in
    "init")
        init_config
        ;;
    "create")
        create_repo
        ;;
    "identity")
        show_identity
        ;;
    "add")
        shift
        git_add "$@"
        ;;
    "commit")
        shift
        git_commit "$@"
        ;;
    "push")
        shift
        git_push "$@"
        ;;
    "pull")
        shift
        git_pull "$@"
        ;;
    "rebase")
        shift
        git_rebase "$@"
        ;;
    "status")
        shift
        git_status "$@"
        ;;
    *)
        usage
        ;;
esac